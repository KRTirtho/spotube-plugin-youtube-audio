import "module:spotube_plugin" as spotube_plugin
import "module:std" as std

var YouTubeEngine = spotube_plugin.YouTubeEngine

class AudioSourceEndpoint {
  var yt: YouTubeEngine
  construct () {
    yt = YouTubeEngine()
  }

  // List of containers and their supported qualities
  get supportedPresets -> List {
    return [
      { type: "lossy", name: "m4a", qualities: [ { bitrate: 44 }, { bitrate: 96 }, { bitrate: 128 }, { bitrate: 256 } ] }.toJson(),      
      { type: "lossy", name: "webm", qualities: [ { bitrate: 44 }, { bitrate: 96 }, { bitrate: 128 }, { bitrate: 256 } ] }.toJson(),
    ]
  }
  
  /// Find matching audio sources for a given track. It can return one or multiple matches.
  /// The first match is considered the best match.
  /// @param track - Map<SpotubeTrackObject>
  /// @returns Future<List<SpotubeAudioSourceMatchObject>>
  fun matches(track: Map) -> List {
    final artists = track["artists"].map((a)=> a["name"]).join(", ")
    
    return yt.search(
      track["isrc"] != null ? track["isrc"] : "${track["name"]} ${artists}"
    ).then((res){
      return res.map((d){
        return {
          "id": d["id"],
          "title": d["title"],
          "artists": [d["author"]],
          "duration": d["duration"],
          "thumbnail": d["thumbnail"],
          "externalUri": "https://youtube.com/watch?v=${d["id"]}",
        }.toJson()
      }).toList()
    })
  }

  /// For the given match, return all available streams.
  /// Each stream represents a unique combination of container and quality.
  /// @param match - Map<SpotubeAudioSourceStreamObject>
  /// @returns Future<List<SpotubeAudioSourceStreamObject>>
  fun streams(match: Map) -> List {
    return yt.streamManifest(match["id"]).then((manifest){
      return manifest.map((stream){
        return {
          "url": stream["url"],
          "container": stream["container"],
          "type": "lossless",
          "codec": "aac",
          "bitrate": stream["bitrate"],
        }.toJson()
      }).toList()
    })
  }
}

export { AudioSourceEndpoint }
import "module:spotube_plugin" as spotube_plugin
import "module:std" as std

var YouTubeEngine = spotube_plugin.YouTubeEngine

class Converter {
  static fun toSpotubeMatchObject(res: List) -> List<Map> {
    return res.map((d){
      return {
        "id": d["id"],
        "title": d["title"],
        "artists": [d["author"]],
        "duration": d["duration"],
        "thumbnail": d["thumbnail"],
        "externalUri": "https://youtube.com/watch?v=${d["id"]}",
      }.toJson()
    }).toList()
  }
}


class AudioSourceEndpoint {
  var yt: YouTubeEngine
  construct () {
    yt = YouTubeEngine()
  }

  // List of containers and their supported qualities
  get supportedPresets -> List {
    return [
      { type: "lossy", name: "mp4", qualities: [ { bitrate: 256000 }, { bitrate: 128000 }, { bitrate: 96000 }, { bitrate: 44000 } ] }.toJson(),      
      { type: "lossy", name: "webm", qualities: [ { bitrate: 256000 }, { bitrate: 128000 }, { bitrate: 96000 }, { bitrate: 44000 } ] }.toJson(),
    ]
  }
  
  /// Find matching audio sources for a given track. It can return one or multiple matches.
  /// The first match is considered the best match.
  /// @param track - Map<SpotubeTrackObject>
  /// @returns Future<List<SpotubeAudioSourceMatchObject>>
  fun matches(track: Map) -> List {
    final artists = track["artists"].map((a)=> a["name"]).join(", ")
    final hasISRC = track["isrc"] != null && track["isrc"].isNotEmpty;
    return yt.search(
      hasISRC ? track["isrc"] : "${track["name"]} ${artists}"
    ).then((res){
      if(res.isEmpty && hasISRC) {
        return yt.search(
          "${track["name"]} ${artists}"
        ).then((res)=> Converter.toSpotubeMatchObject(res))
      }
      return Converter.toSpotubeMatchObject(res)
    })
  }

  /// For the given match, return all available streams.
  /// Each stream represents a unique combination of container and quality.
  /// @param match - Map<SpotubeAudioSourceStreamObject>
  /// @returns Future<List<SpotubeAudioSourceStreamObject>>
  fun streams(match: Map) -> List {
    return yt.streamManifest(match["id"]).then((manifest){
      return manifest.map((stream){
        return {
          "url": stream["url"],
          "container": stream["container"],
          "type": "lossless",
          "codec": "aac",
          "bitrate": stream["bitrate"],
        }.toJson()
      }).toList()
    })
  }
}

export { AudioSourceEndpoint }